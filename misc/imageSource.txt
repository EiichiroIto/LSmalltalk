COMMENT
COMMENT		Source for the initial image
COMMENT
COMMENT		must be compiled by the image builder
COMMENT	
COMMENT-----------------------------------------------------------
COMMENT RAWCLASS name   instanceOf subclassOf  (instance variable names)
COMMENT  or... CLASS name subclassOf (instance vars)
COMMENT RAWCLASS doesn't automatically build Meta class; CLASS does
COMMENT-----------------------------------------------------------
COMMENT		The strange circular world at the beginning
COMMENT RAWCLASS Object MetaObject nil
RAWCLASS LClass      MetaLClass LObject      name parentClass methods size variables
RAWCLASS MetaLObject LClass     LClass
RAWCLASS MetaLClass  LClass     MetaLObject
COMMENT--------------------------------------------------------
COMMENT-------then, the remaining classes in the initial image
COMMENT----------------------------
CLASS LUndefined     LObject
CLASS LBoolean       LObject
CLASS LTrue          LBoolean
CLASS LFalse         LBoolean
CLASS LProcess       LObject context state result
CLASS LContext       LObject method arguments temporaries stack bytePointer stackTop previousContext
CLASS LBlock         LContext argumentLocation creatingContext oldBytePointer
CLASS LMethod        LObject name byteCodes literals stackSize temporarySize class text
CLASS LMagnitude     LObject
RAWCLASS MetaLSymbol    LClass         MetaLMagnitude     symbols
RAWCLASS LSymbol        MetaLSymbol    LMagnitude
RAWCLASS MetaLChar      LClass         MetaLMagnitude     chars
RAWCLASS LChar          MetaLChar      LMagnitude         value
CLASS LCollection    LMagnitude
CLASS LList          LCollection         elements
CLASS LDictionary    LCollection        keys values
CLASS LArray         LCollection
CLASS LOrderedArray  LArray
CLASS LByteArray     LArray
COMMENT CLASS MetaLString    LClass         MetaLArray
CLASS LString        LArray
CLASS LSet	    LCollection		members growth
CLASS LIdentitySet   LSet
CLASS LNumber        LMagnitude
CLASS LInteger       LNumber
COMMENT CLASS LSmallInt      LNumber
RAWCLASS MetaLSmallInt LClass           MetaLNumber           seed
RAWCLASS LSmallInt   MetaLSmallInt LNumber
CLASS LLink          LObject            value next
CLASS LNode          LObject            value left right
CLASS LInterval      LCollection        low high step
CLASS LFile          LObject            fileID
CLASS LAssociation	LMagnitude	key value
CLASS LTree		LCollection	root
COMMENT ---------- Classes having to do with parsing ------------
CLASS LParser LObject text index tokenType token argNames tempNames instNames maxTemps errBlock lineNum
CLASS LParserNode LObject lineNum
CLASS LEncoder LObject name byteCodes index literals stackSize maxStack
CLASS LBodyNode LParserNode statements
CLASS LReturnNode LParserNode expression
CLASS LAssignNode LParserNode target expression
CLASS LLiteralNode LParserNode value
CLASS LArgumentNode LParserNode position
CLASS LTemporaryNode LParserNode position
CLASS LInstNode LParserNode position
CLASS LPrimitiveNode LParserNode number arguments
CLASS LBlockNode LParserNode statements temporaryLocation
CLASS LCascadeNode LParserNode head list
CLASS LMessageNode LParserNode receiver name arguments
COMMENT ---------- method bodies ------------
COMMENT -----------LObject-------------------
METHOD MetaLObject
in: object at: index put: value
	" change data field in object, used during initialization "
	" returns the intialized object "
	self primNo: 5 a: value b: object c: index.
!
METHOD LObject
in: object at: index
	" browse instance variable via debugger "
	self primNo: 24 a: object b: index.
	self primitiveFailed
!
METHOD LObject
isNil
	^ false
!
METHOD LObject
notNil
	^ true
!
METHOD LObject
== arg
	self primNo: 1 a: self b: arg.
!
METHOD LObject
= arg
	^ self == arg
!
METHOD LObject
~= arg
	^ (self = arg) not
!
METHOD LObject
~~ arg
	^ (self == arg) not
!
METHOD LObject
class
	self primNo: 2 a: self.
!
METHOD LObject
printString
	^ self class printString
!
METHOD LObject
isMemberOf: aClass
	^ self class == aClass
!
METHOD LObject
isKindOf: aClass	| clas |
	clas := self class.
	[ clas notNil ] whileTrue:
		[ clas == aClass ifTrue: [ ^ true ].
		  clas := clas superclass ].
	^ false
!
METHOD LObject
respondsTo: aMessage
	^ self class allMethods includes: aMessage
!
METHOD LObject
print
	self printString do: [ :c | c print ]
!
METHOD LObject
printNl
	self print. LChar newline print
!
METHOD LObject
question: text	| answer |
	text print.
	answer := LString input.
	(answer notNil)
		ifTrue: [ answer := answer at: 1 ifAbsent: [ $n ] ].
	^ answer = $y or: [ answer = $Y]
!
METHOD LObject
error: str
		" print the message "
	str printNl.
		" then halt "
	self primNo: 19.
!
METHOD LObject
debug
	self primNo: 18.
!
METHOD LObject
primitiveFailed
	self error: 'Primitive failed'
!
METHOD LObject
species
	" By default, we re-instantiate ourselves as our own Class "
	^ self class
!
METHOD LObject
hash
	" Most objects should generate something based on their value "
	^ self class printString hash
!
METHOD LObject
become: other
	" Exchange identity with another object "
	(LArray with: self) elementsExchangeIdentityWith: (LArray with: other)
!
METHOD LObject
doesNotUnderstand: aSel
	self error: (self printString + ' (class '+
		(self class printString) +
		'): does not understand ' + aSel printString)
!
METHOD LObject
basicSize
	self primNo: 4 a: self.
	self primitiveFailed
!
METHOD LObject
subclassResponsibility
	self error: 'Subclass responsibility'
!
METHOD LObject
basicDo: aBlock
	^ self do: aBlock
!
COMMENT ---------Class-------------------
METHOD LClass
name: n parent: c variables: v
	" create a new class with the given characteristics "
	name := n.
	parentClass := c.
	methods := LDictionary new.
	size := v size + c size.
	variables := v
!
METHOD LClass
size
	^ size
!
METHOD LClass
superclass
	^ parentClass
!
METHOD LClass
variables
	^ variables
!
METHOD LClass
subclasses
	self subclasses: 0
!
METHOD LClass
subclasses: indent
	LSmalltalk do: [ :obj |
		((obj isKindOf: LClass) and: [ obj superclass == self])
			ifTrue: [
				1 to: indent do: [:ignore| $  print ].
				obj printNl.
				obj subclasses: indent + 4 ] ]
!
METHOD LClass
listMethods
	methods keysDo:
		[ :name | name printNl ]
!
METHOD LClass
allMethods | allMethods |
	parentClass isNil
		ifTrue: [ allMethods := LDictionary new ]
		ifFalse: [ allMethods := parentClass allMethods ].
	methods binaryDo: [ :n :m | allMethods at: n put: m ].
	^ allMethods
!
METHOD LClass
listAllMethods
	self allMethods keysDo: [:n| n printNl ]
!
METHOD LClass
viewMethod: nm  | meth |
	meth := self allMethods at: nm
		ifAbsent: [ ^ self error: 'no such method'].
	meth text print.
	^ ''
!
METHOD LClass
editMethod: nm	| meth text |
	meth := methods at: nm
		ifAbsent: [ ^ self error: 'no such method'].
	text := meth text edit.
	(self question: 'compile method?')
		ifTrue: [ self addMethod: text ]
!
METHOD LClass
subclass: nm
	^ self subclass: nm variables: (LArray new: 0)
		classVariables: (LArray new: 0)
!
METHOD LClass
subclass: nm variables: v
	^ self subclass: nm variables: v classVariables: (LArray new: 0)
!
METHOD LClass
subclass: nm variables: v classVariables: cv | meta |
	meta := LClass new name: ('Meta' + nm asString) asSymbol
		parent: self class
		variables: cv.
	LSmalltalk at: nm put: ( meta new name: nm
		parent: self
		variables: v ).
	^ 'subclass created: ' + nm printString
!
METHOD LClass
addMethod	| text |
	text := ' ' edit.
	(self question: 'compile method?')
		ifTrue: [ self addMethod: text ]
!
METHOD LClass
addMethod: text | meth |
	meth := self parseMethod: text.
	meth notNil ifTrue: [
		methods at: meth name put: meth.
		LMethod flushCache.
		'ok' printNl.
		^ meth
	].
	^ nil
!
METHOD LClass
removeMethod: methName
	methods removeKey: methName ifAbsent: [
		self error: 'Method not present: ' + (methName printString)
	].
	LMethod flushCache.
!
METHOD LClass
view: methodName
		" print the text of the given method "
	(methods at: methodName
		ifAbsent: [ ^ self error: 'no such method'])
			text print
!
METHOD LClass
parseMethod: text
	^ (LParser new
		text: text instanceVars: self instanceVariables) parse: self
!
METHOD LClass
new
	" return a new instance of ourselves "
	self primNo: 7 a: self b: size.
!
METHOD LClass
basicNew
	" Like new "
	self primNo: 7 a: self b: size.
!
METHOD LClass
instanceVariables	| names |
		" return all our variable names "
	parentClass notNil
		ifTrue: [ names := parentClass instanceVariables ]
		ifFalse: [ names := LArray new: 0 ].
	(variables isNil or: [ variables isEmpty ])
		ifFalse: [ names := names + variables ].
	^ names
!
METHOD LClass
methods
	" return the tree of methods "
	^ methods
!
METHOD LClass
printString
	" just return our name "
	^ name printString
!
METHOD LClass
isMeta
	^ (name asString from: 1 to: 4) = 'Meta'
!
METHOD LClass
fileOut: f | tag |
	self isMeta ifTrue: [
		tag := '=' + (name asString from: 5 to: 99)
	] ifFalse: [
		tag := '!' + name asString
	].
	tag := tag + LString newline.
	methods do: [:m|
		f write: tag.
		f write: (m text printString).
		f write: ('!' + LString newline)
	]
!
METHOD LClass
fileOut | f |
	f := LFile openWrite: (name printString + '.st').
	f isNil ifTrue: [ self error: 'File creation failed' ].
	self isMeta ifFalse: [
		self class fileOut: f
	].
	self fileOut: f.
	f close
!
COMMENT -----------LUndefined--------------
METHOD MetaLUndefined
new
	" there is only one nil object "
	^ nil
!
METHOD LUndefined
printString
	^ 'nil'
!
METHOD LUndefined
isNil
	" yes, we are nil "
	^ true
!
METHOD LUndefined
notNil
	" no, we are not not-nil "
	^ false
!
METHOD LUndefined
main	| command |
	" initialize classes "
	LChar initialize.

	" main execution loop "
	[ '-> ' print. command := LString input. command notNil ]
		whileTrue: [ command isEmpty
			ifFalse: [ command doIt printNl ] ]
!
COMMENT -----------Boolean--------------
METHOD LBoolean
and: aBlock
	^ self
		ifTrue: [ aBlock value ]
		ifFalse: [ false ]
!
METHOD LBoolean
or: aBlock
	^ self
		ifTrue: [ true ]
		ifFalse: [ aBlock value ]
!
METHOD LBoolean
not
	^ self
		ifTrue: [ false ]
		ifFalse: [ true ]
!
METHOD LBoolean
ifFalse: falseBlock ifTrue: trueBlock
	^ self ifTrue: [ trueBlock  value ] ifFalse: [ falseBlock value ]
!
METHOD LBoolean
ifTrue: aBlock
	^ self ifTrue: [ aBlock value ] ifFalse: [ nil ]
!
METHOD LBoolean
ifFalse: aBlock
	^ self ifTrue: [ nil ] ifFalse: [ aBlock value ]
!
COMMENT -----------True--------------
METHOD MetaLTrue
new
	" there is only one true value "
	^ true
!
METHOD LTrue
not
	^ false
!
METHOD LTrue
printString
	^ 'true'
!
METHOD LTrue
ifTrue: trueBlock ifFalse: falseBlock
	^ trueBlock value
!
METHOD LTrue
or: aBlock
	^ true
!
METHOD LTrue
and: aBlock
	^ aBlock value
!
COMMENT -----------LFalse--------------
METHOD MetaLFalse
new
	" there is only one false value "
	^ false
!
METHOD LFalse
not
	^ true
!
METHOD LFalse
printString
	^ 'false'
!
METHOD LFalse
ifTrue: trueBlock ifFalse: falseBlock
	^ falseBlock value
!
METHOD LFalse
or: aBlock
	^ aBlock value
!
METHOD LFalse
and: aBlock
	^ false
!
COMMENT -----------LProcess--------------
METHOD LProcess
doExecute: ticks
	self primNo: 6 a: self b: ticks.
!
METHOD LProcess
context: aContext
	context := aContext
!
METHOD LProcess
context
	^ context
!
METHOD LProcess
execute | r |
	r := self doExecute: 0.
	(r = 3) ifTrue: [
		" Note: state field is filled in with arguments on error "
		(state at: 1) print. ' (class ' print.
		(state at: 1) class print. ') ' print.
		'does not understand: ' print.  result printNl
	].
	(r = 4) ifTrue: [ ^ result ]
		ifFalse: [ 'Backtrace:' printNl.
			context backtrace. ^ nil ]
!
COMMENT -----------LContext--------------
METHOD LContext
setup: aMethod withArguments: a
	method := aMethod.
	arguments := LArray new: 1.
	bytePointer := 0.
	stack := LArray new: method stackSize.
	stackTop := 0.
	temporaries := LArray new: method temporarySize.
!
METHOD LContext
perform: aMethod withArguments: a | proc |
	self setup: aMethod withArguments: a.
	proc := LProcess new.
	proc context: self.
	^ proc execute
!
METHOD LContext
backtrace | narg |
		" backtrace context calls "
	narg := 0.
	method name print.
	'(' print.
	arguments do: [:a |
		(narg > 0) ifTrue: [ ', ' print ].
		a class print.
		narg := narg+1
	].
	')' printNl.
	previousContext notNil
		ifTrue: [ previousContext backtrace ]
!
METHOD LContext
previousContext
	^ previousContext
!
COMMENT ---------- LBlocks ------------
METHOD LBlock
argCount
	self error: 'Incorrect argument passing to LBlock'
!
METHOD LBlock
value
	" start block execution "
	self primNo: 8 a: self.
	(self argCount)
!
METHOD LBlock
value: a
	" start block execution "
	self primNo: 8 a: a b: self.
	(self argCount)
!
METHOD LBlock
value: a value: b
	" start block execution "
	self primNo: 8 a: a b: b c: self.
	(self argCount)
!
METHOD LBlock
whileTrue: aBlock
	self value ifTrue: [ aBlock value. ^ self whileTrue: aBlock ]
!
METHOD LBlock
whileFalse: aBlock
	self value ifFalse: [ aBlock value. ^ self whileFalse: aBlock ]
!
METHOD LBlock
backtrace | narg |
		" backtrace context calls "
	'block from ' print. method name print.
	'(' print.
	narg := 0.
	arguments do: [:a |
		(narg > 0) ifTrue: [', ' print ].
		a class print.
		narg := narg+1
	].
	')' printNl.
	previousContext notNil
		ifTrue: [ previousContext backtrace ]
!
COMMENT -----------LMagnitude--------------
METHOD LMagnitude
<= arg
	^ self < arg or: [ self = arg ]
!
METHOD LMagnitude
> arg
	^ arg < self
!
METHOD LMagnitude
>= arg
	^ (self > arg) or: [ self = arg ]
!
METHOD LMagnitude
min: arg
	^ self < arg ifTrue: [ self ] ifFalse: [ arg ]
!
METHOD LMagnitude
max: arg
	^ self < arg ifTrue: [ arg ] ifFalse: [ self ]
!
METHOD LMagnitude
between: low and: high
	^ low <= self and: [ self <= high ]
!
COMMENT -----------LSymbol--------------
METHOD MetaLSymbol
intern: string
	self primNo: 23 a: string b: LSymbol.
!
METHOD MetaLSymbol
new: fromString | sym |
	^ symbols at: fromString
		ifAbsent: [ symbols add: (self intern: fromString) ]
!
METHOD LSymbol
printString
	self primNo: 23 a: self b: LString.
!
METHOD LSymbol
asString
	^self printString
!
METHOD LSymbol
hash
	^self printString hash
!
METHOD LSymbol
asSymbol
	^self
!
METHOD LSymbol
= aString
		" works with either symbol or string arguments "
	^ self printString = aString printString
!
METHOD LSymbol
< arg
		" works with either symbol or string arguments "
	^ self printString < arg printString
!
COMMENT -----------Method--------------
METHOD MetaLMethod
name: n byteCodes: b literals: l stackSize: s temporarySize: ts class: c text: t
	| newMethod |
	newMethod := self new.
	super in: newMethod at: 1 put: n.
	super in: newMethod at: 2 put: b.
	super in: newMethod at: 3 put: l.
	super in: newMethod at: 4 put: s.
	super in: newMethod at: 5 put: ts.
	super in: newMethod at: 6 put: c.
	super in: newMethod at: 7 put: t.
	^ newMethod
!
METHOD MetaLMethod
flushCache
	self primNo: 34.
	self primitiveFailed
!
METHOD LMethod
byteCodes
	^ byteCodes
!
METHOD LMethod
literals
	^ literals
!
METHOD LMethod
text
	^ text
!
METHOD LMethod
name
	^ name
!
METHOD LMethod
stackSize
	^ stackSize
!
METHOD LMethod
temporarySize
	^temporarySize
!
METHOD LMethod
args: argNames inst: instNames temp: tempNames
	" Hook for recording symbolic debug "
!
COMMENT -----------LChars--------------
METHOD MetaLChar
initialize
	chars isNil ifTrue: [
		chars := LArray new: 257.
		1 to: 257 do: [:idx|
			chars at: idx put: (LChar basicNew: idx-1)
		]
	]
!
METHOD MetaLChar
basicNew: value
	" create and initialize a new char "
	^ self in: self new at: 1 put: value
!
METHOD MetaLChar
new: value
	" return unique LChar for ASCII value (or EOF) "
	(value < 257) ifTrue: [ ^ chars at: value+1 ].

	" otherwise build a custom LChar "
	^ self basicNew: value
!
METHOD MetaLChar
newline
		" return newline character "
	^ self new: 10
!
METHOD MetaLChar
tab
		" return tab character "
	^ self new: 9
!
METHOD MetaLChar
eof
		" return an EOF indication--not a true LChar, but polymorphic "
	^ self new: 256
!
METHOD MetaLChar
doInput
	self primNo: 9.
!
METHOD MetaLChar
input	| c |
	" read a single char from input stream "
	c := self doInput.
	(c notNil)
		ifTrue: [ ^self new: c ]
		ifFalse: [ ^nil ]
!
METHOD LChar
value
		" return our ascii value as an integer "
	^ value
!
METHOD LChar
hash
	^ value
!
METHOD LChar
isDigit
	^ self between: $0 and: $9
!
METHOD LChar
isLowerCase
	^ self between: $a and: $z
!
METHOD LChar
isUpperCase
	^ self between: $A and: $Z
!
METHOD LChar
isAlphabetic
	^ self isLowerCase or: [ self isUpperCase ]
!
METHOD LChar
isEOF
	^ value = 256
!
METHOD LChar
lowerCase
	self isUpperCase
		ifTrue: [ ^ LChar new: (value - 65) + 97 ]
!
METHOD LChar
upperCase
	self isLowerCase
		ifTrue: [ ^ LChar new: (value - 97) + 65 ]
!
METHOD LChar
isAlphanumeric
		" are we a letter or a digit? "
	^ self isAlphabetic or: [ self isDigit ]
!
METHOD LChar
isBlank
		"spaces, tabs and newlines are all blank"
	^ value = 32 or: [ value = 9 or: [ value = 10 ] ]
!
METHOD LChar
print
	self primNo: 3 a: value.
!
METHOD LChar
asString
	" return char as a string value "
	| s |
	s := LString new: 1.
	s at: 1 put: self.
	^ s
!
METHOD LChar
printString
	| s |
	s := LString new: 2.
	s at: 1 put: $$.
	s at: 2 put: self.
	^ s
!
METHOD LChar
= aChar
	^ value = aChar value
!
METHOD LChar
< aChar
	^ value < aChar value
!
COMMENT ---------- LCollection ------------
METHOD LCollection
noElement
	self error: 'Element not present'
!
METHOD LCollection
size	| tally |
	tally := 0.
	self do: [:i | tally := tally + 1].
	^ tally
!
METHOD LCollection
isEmpty
		" empty if there are no elements "
	^ self size = 0
!
METHOD LCollection
at: value ifAbsent: exceptionBlock
	self do: [ :element | element = value ifTrue: [ ^ element ]].
	^ exceptionBlock value
!
METHOD LCollection
at: value
	^ self at: value ifAbsent: [ self noElement ]
!
METHOD LCollection
includes: value
	self at: value ifAbsent: [ ^ false ].
	^ true
!
METHOD LCollection
asArray		| newArray index |
	newArray := LArray new: self size.
	index := 1.
	self do: [ :element | newArray at: index put: element.
		index := index + 1 ].
	^ newArray
!
METHOD LCollection
from: argLow to: argHigh | ret idx size base low high |
	low := argLow max: 1.
	high := argHigh min: self size.
	size := (high - low) + 1.
	(size < 1) ifTrue: [ ^ LArray new: 0 ].
	ret := LArray new: size.
	base := idx := 1.
	self do: [:elem|
		((idx >= low) and: [idx <= high]) ifTrue: [
			ret at: base put: elem.
			base := base + 1.
			(base > size) ifTrue: [ ^ ret ]
		].
		idx := idx + 1.
	].
	^ ret
!
METHOD LCollection
from: argLow
	^ self from: argLow to: (self size)
!
METHOD LCollection
asString	| newString index |
	newString := LString new: self size.
	index := 1.
	self do: [ :element | newString at: index put: element.
		index := index + 1 ].
	^ newString
!
METHOD LCollection
asList
	^ LList new addAll: self
!
METHOD LCollection
collect: transformBlock	| newList |
	newList := LList new.
	self do: [:element | newList addLast: (transformBlock value: element)].
	^ newList
!
METHOD LCollection
select: testBlock	| newList |
	newList := LList new.
	self do: [:x | (testBlock value: x) ifTrue: [newList addLast: x]].
	^ newList
!
METHOD LCollection
< aCollection
	self do: [ :element | (aCollection includes: element)
		ifFalse: [ ^ false ] ].
	^ true
!
METHOD LCollection
= aCollection
	^ self < aCollection and: [ aCollection < self ]
!
METHOD LCollection
reject: testBlock
		" select the things that do not match predicate "
	^ self select: [:x | (testBlock value: x) not ]
!
METHOD LCollection
printString | count res |
	res := super printString.
	(self respondsTo: #do:) ifFalse: [ ^ res ].
	count := 0.
	res := res + ' ('.
	self basicDo: [:elem| 
		(count = 0) ifFalse: [ res := res + ' ' ].
		res := res + elem printString.
		count := count + 1.
		(count >= 20) ifTrue: [ ^ res + ' ...)' ]
	].
	^ res + ')'
!
METHOD LCollection
occurencesOf: obj | count |
	count := 0.
	self do: [:o| (o = obj) ifTrue: [ count := count + 1]].
	^ count
!
METHOD LCollection
anyOne
	self do: [:it| ^ it].
	self emptyCollection
!
METHOD LCollection
emptyCollection
	self error: (self class printString + ' is empty')
!
METHOD LCollection
do: aBlock
	self subclassResponsibility
!
COMMENT ---------- LArray ------------
METHOD MetaLArray
new
	^ self new: 0
!
METHOD MetaLArray
new: sz
	self primNo: 7 a: self b: sz.
!
METHOD MetaLArray
with: elemA | ret |
	ret := self new: 1.
	ret at: 1 put: elemA.
	^ ret
!
METHOD MetaLArray
with: elemA with: elemB | ret |
	ret := self new: 2.
	ret at: 1 put: elemA.
	ret at: 2 put: elemB.
	^ ret
!
METHOD MetaLArray
with: elemA with: elemB with: elemC | ret |
	ret := self new: 3.
	ret at: 1 put: elemA.
	ret at: 2 put: elemB.
	ret at: 3 put: elemC.
	^ ret
!
METHOD LArray
badIndex
	self error: 'array indexing error'
!
METHOD LArray
at: index
	self primNo: 24 a: self b: index.
	(self includesKey: index) ifFalse: [ self badIndex ].
	self primitiveFailed
!
METHOD LArray
at: index ifAbsent: exceptionBlock
	self primNo: 24 a: self b: index.
	exceptionBlock value
!
METHOD LArray
includes: aValue
	self do: [ :element | element = aValue ifTrue: [ ^ true ]].
	^ false
!
METHOD LArray
indexOf: aValue
	1 to: self size do: [:idx|
		((self at: idx) == aValue) ifTrue: [ ^ idx ]
	].
	^ nil
!
METHOD LArray
indexOfVal: aValue
	1 to: self size do: [:idx|
		((self at: idx) = aValue) ifTrue: [ ^ idx ]
	].
	^ nil
!
METHOD LArray
copy
	^ self asArray
!
METHOD LArray
with: newItem	| newArray size |
	size := self size.
	newArray := self class new: size + 1.
	newArray replaceFrom: 1 to: size with: self.
	newArray at: size + 1 put: newItem.
	^ newArray
!
METHOD LArray
+ aValue	| size1 size2 newValue |
	" catenate two strings together "
	size1 := self size.
	size2 := aValue size.
	newValue := self class new: (size1 + size2).
	newValue replaceFrom: 1 to: size1 with: self.
	newValue replaceFrom: size1+1 to: size1+size2 with: aValue.
	^ newValue
!
METHOD LArray
size
	" compute number of elements "
	self primNo: 4 a: self.
!
METHOD LArray
at: index put: value
	self primNo: 5 a: value b: self c: index.
	(self includesKey: index) ifFalse: [ self badIndex ].
	self primitiveFailed
!
METHOD LArray
do: aBlock
	1 to: self size do: [:i | aBlock value: (self at: i)]
!
METHOD LArray
< arg		| selfsize argsize |
	selfsize := self size. argsize := arg size.
	1 to: (selfsize min: argsize)
		do: [:i | (self at: i) ~= (arg at: i)
			ifTrue: [ ^ (self at: i) < (arg at: i) ]].
	^ selfsize < argsize
!
METHOD LArray
= anArray
	self size = anArray size ifFalse: [ ^ false ].
	1 to: self size do:
		[:i | (self at: i) = (anArray at: i)
			ifFalse: [ ^ false ]].
	^ true
!
METHOD LArray
includesKey: index
	^ index between: 1 and: self size
!
METHOD LArray
insert: value at: position | newArray newSize |
	newSize := self size + 1.
	newArray := self class new: newSize.
	newArray replaceFrom: 1 to: position-1 with: self.
	newArray at: position put: value.
	newArray replaceFrom: position+1 to: newSize with:
		self startingAt: position.
	^ newArray
!
METHOD LArray
removeIndex: position  | newArray newSize |
	newSize := self size - 1.
	newArray := self class new: newSize.
	newArray replaceFrom: 1 to: position-1 with: self.
	newArray replaceFrom: position to: newSize with: self
		startingAt: position+1.
	^ newArray
!
METHOD LArray
first
	^self at: 1
!
METHOD LArray
from: low to: high | start stop size obj |
	start := low max: 0.
	stop := high min: self size.
	size := (stop + 1 - start) max: 0.
	obj := (self species) new: size.
	1 to: size do: [ :i |
		obj at: i put: (self at: start).
		start := start + 1 ].
	^ obj
!
METHOD LArray
hash | sz |
	sz := self size.
	(sz < 2) ifTrue: [
		(sz = 1) ifTrue: [ ^ (self at: 1) hash + sz ].
		^ 0
	].
	^ (self at: 1) hash + (self at: sz) hash
!
METHOD LArray
elementsExchangeIdentityWith: otherArray
	self primNo: 35 a: self b: otherArray.
	self primitiveFailed
!
METHOD LArray
replaceFrom: start to: stop with: replacement
	^ self replaceFrom: start to: stop with: replacement startingAt: 1
!
METHOD LArray
replaceFrom: start to: stop with: replacement startingAt: repStart | base |
	self primNo: 38 a: start b: stop c: replacement d: repStart e: self.
	base := repStart-1.
	0 to: (stop - start) do: [:idx|
		self at: (idx + start) put:
			(replacement at: (idx + repStart))
	]
!
COMMENT ---------- LOrderedArray ------------
METHOD LOrderedArray
add: value
	^ self insert: value at: (self location: value)
!
METHOD LOrderedArray
includes: value | position |
	position := self location: value.
	^ (position <= self size) and: [ value = (self at: position)]
!
METHOD LOrderedArray
location: value | low high mid |
	low := 1.
	high := self size + 1.
	[ low < high ] whileTrue:
		[ mid := (low + high) quo: 2.
		(self at: mid) < value
			ifTrue: [ low := mid + 1 ]
			ifFalse: [ high := mid ] ].
	^ low
!
COMMENT ---------- LByteArrays ------------
METHOD MetaLByteArray
new: size
	self primNo: 20 a: self b: size.
!
METHOD LByteArray
basicAt: index
	self primNo: 21 a: self b: index.
	^nil
!
METHOD LByteArray
at: index
	self primNo: 21 a: self b: index.
	(self includesKey: index) ifFalse: [ self badIndex ].
	self primitiveFailed
!
METHOD LByteArray
at: index ifAbsent: exceptionBlock
	self primNo: 21 a: self b: index.
	exceptionBlock value
!
METHOD LByteArray
at: index put: aValue
	self primNo: 22 a: aValue b: self c: index.
	(self includesKey: index) ifFalse: [ self badIndex ].
	self primitiveFailed
!
METHOD LByteArray
asString | str sz |
	sz := self size.
	str := LString new: sz.
	1 to: sz do: [:i| str at: i put: ((self at: i) asChar)].
	^ str
!
COMMENT ---------- LStrings ------------
METHOD MetaLString
new: size
	self primNo: 20 a: self b: size.
!
METHOD MetaLString
input	| value c nl |
	" read a line from input "
	value := ''. nl := LChar newline.
	[ c := LChar input.
	  c isNil ifTrue: [ ^ nil ]. c ~= nl ] whileTrue:
		[ value := value + c asString ].
	^ value
!
METHOD MetaLString
newline
	^ LChar newline asString
!
METHOD MetaLString
tab
	^ LChar tab asString
!
METHOD LString
edit
	self primNo: 105 a: self.
!
METHOD LString
break: separators  | words word |
	" break string into words, using separators "
	word := ''.
	words := LList new.
	self do: [:c |
		(separators includes: c)
			ifTrue: [
				(word size > 0) " found a word "
					ifTrue: [ words addLast: word.
							word := '' ] ]
			ifFalse: [ word := word + c asString ] ].
		" maybe a last word "
	(word size > 0) ifTrue: [ words addLast: word ].
	^ words
!
METHOD LString
collect: transformationBlock
	^ (super collect: transformationBlock) asString
!
METHOD LString
reverse
	^ self asList reverse asString
!
METHOD LString
select: testBlock
	^ (super select: testBlock) asString
!
METHOD LString
printString
	^ self
!
METHOD LString
printWidth: width | ret |
	(self size >= width absolute) ifTrue: [ ^ self ].
	ret := self.
	(width negative) ifTrue: [
			(self size + 1) to: (width negated) do:
				[:ignore| ret := ' ' + ret].
		]
		ifFalse: [
			(self size + 1) to: width do:
				[:ignore| ret := ret + ' ' ].
		].
	^ret
!
METHOD LString
asSymbol
	^ LSymbol new: self
!
METHOD LString
doIt	| meth |
	meth := LUndefined parseMethod: 'doItCommand ^' + self.
	^ meth notNil
		ifTrue: [ ^ LContext new
			  perform: meth withArguments: (LArray new: 1) ]
!
METHOD LString
basicAt: index
	self primNo: 21 a: self b: index.
	^nil
!
METHOD LString
at: index
	^self at: index ifAbsent: [ self badIndex ]
!
METHOD LString
at: index ifAbsent: exceptionBlock | c |
	c := self basicAt: index.
	(c isNil)
	     ifTrue: [ ^ exceptionBlock value ]
	     ifFalse: [ ^ LChar new: c ]
!
METHOD LString
basicAt: index put: value
	self primNo: 22 a: value b: self c: index.
	^nil
!
METHOD LString
at: index put: aValue
	(self basicAt: index put: aValue value) isNil ifTrue: [
		self badIndex
	]
!
METHOD LString
copy
	" make a clone of ourself "
	self primNo: 23 a: self b: LString.
!
METHOD LString
asNumber | val |
	" parse a base-10 ASCII number, return nil on failure "
	val := 0.
	self do: [:c|
		c isDigit ifFalse: [^nil].
		val := (val * 10) + (c value - 48)
	].
	^val
!
METHOD LString
hash | sz |
	sz := self size.
	(sz < 2) ifTrue: [
		(sz = 1) ifTrue: [ ^ (self at: 1) value ].
		^ 0
	].
	^ (self at: 1) value + (self at: sz) value
!
METHOD LString
lowerCase | ret c |
	ret := LString new: (self size).
	1 to: self size do: [:x|
		c := self at: x.
		c isUpperCase ifTrue: [c := c lowerCase].
		ret at: x put: c
	].
	^ ret
!
METHOD LString
indexOf: val | c s |
	" For non-strings, search scalar LArray elements "
	(val isKindOf: LString) ifFalse: [ ^ super indexOf: val ].

	" Otherwise look for substring match "
	c := val at: 1.
	s := val size.
	1 to: (self size - s + 1) do: [:idx|
		" Cheap check for initial char equality "
		((self at: idx) = c) ifTrue: [
			((self from: idx to: (idx + s - 1)) = val)
				ifTrue: [ ^ idx ]
		]
	].
	^ nil
!
COMMENT --------- LList -----------
METHOD MetaLList
with: elemA	| newList |
	newList := self new.
	newList add: elemA.
	^ newList
!
METHOD MetaLList
with: elemA with: elemB	| newList |
	newList := self new.
	newList add: elemB.  newList add: elemA.
	^ newList
!
METHOD MetaLList
with: elemA with: elemB with: elemC	| newList |
	newList := self new.
	newList add: elemC.  newList add: elemB.  newList add: elemA.
	^ newList
!
METHOD LList
add: anElement
	elements := LLink value: anElement next: elements.
	^ anElement
!
METHOD LList
addLast: anElement
	elements isNil
		ifTrue: [ self add: anElement]
		ifFalse: [ elements addLast: anElement ].
	^ anElement
!
METHOD LList
addAll: aCollection
	aCollection do: [ :element | self addLast: element ]
!
METHOD LList
+ aCollection
	^ self addAll: aCollection
!
METHOD LList
copy
	^ self asList
!
METHOD LList
badIndex
	self error: 'Invalid LList index'
!
METHOD LList
findLink: index ifAbsent: aBlock | idx link |
	link := elements.
	idx := index.
	link isNil ifTrue: [ ^ aBlock value ].
	[ link notNil ] whileTrue: [
		idx := idx-1.
		(idx = 0) ifTrue: [ ^ link ].
		link := link next
	].
	^ aBlock value
!
METHOD LList
at: index | link |
	link := self findLink: index ifAbsent: [ self badIndex ].
	^ link value
!
METHOD LList
at: index ifAbsent: aBlock | link |
	link := self findLink: index ifAbsent: [nil].
	link isNil ifTrue: [ ^ aBlock value ].
	^ link value
!
METHOD LList
at: index put: value | link |
	link := self findLink: index.
	link value: value
!
METHOD LList
first
	^ self at: 1
!
METHOD LList
isEmpty
	^ elements isNil
!
METHOD LList
removeFirst
	elements isNil
		ifTrue: [ self emptyCollection ]
		ifFalse: [ elements := elements next ]
!
METHOD LList
remove: anElement
	self remove: anElement
		ifAbsent: [ self emptyCollection ]
!
METHOD LList
reverse | newList |
	newList := LList new.
	self do: [ :element | newList add: element ].
	^ newList
!
METHOD LList
remove: anElement ifAbsent: exceptionBlock
	elements isNil
		ifTrue: [ exceptionBlock value ]
		ifFalse: [ elements remove: anElement ifAbsent: exceptionBlock ]
!
METHOD LList
do: aBlock
	^ elements notNil ifTrue: [ elements do: aBlock ]
!
METHOD LList
reverseDo: aBlock
	^ elements notNil ifTrue: [ elements reverseDo: aBlock ]
!
METHOD LList
select: testBlock | newList |
	newList := LList new.
	self reverseDo: [:element | (testBlock value: element)
		ifTrue: [ newList add: element ] ].
	^ newList
!
COMMENT ---------- LDictionary ------------
METHOD MetaLDictionary
new | newDict |
	newDict := super new.
	self in: newDict at: 1 put: (LOrderedArray new: 0).
	self in: newDict at: 2 put: (LArray new: 0).
	^ newDict
!
METHOD LDictionary
noKey
	self error: 'key not found in dictionary lookup'
!
METHOD LDictionary
at: key
	^ self at: key ifAbsent: [ self noKey ]
!
METHOD LDictionary
at: key put: value | position |
	position := keys location: key.
	(position <= keys size and: [ key = (keys at: position)])
		ifTrue: [ values at: position put: value ]
		ifFalse: [ keys := keys insert: key at: position.
			values := values insert: value at: position ].
	^ value
!
METHOD LDictionary
at: key ifAbsent: exceptionBlock | position |
	position := keys location: key.
	((position <= keys size) and: [ key = (keys at: position)])
		ifTrue: [ ^ values at: position ]
		ifFalse: [ ^ exceptionBlock value ]
!
METHOD LDictionary
binaryDo: aBlock
	1 to: keys size do:
		[:i | aBlock value: (keys at: i) value: (values at: i) ]
!
METHOD LDictionary
keysDo: aBlock
	1 to: keys size do: [:i| aBlock value: (keys at: i)]
!
METHOD LDictionary
keysAsArray | i ret |
	ret := LArray new: keys size.
	1 to: keys size do: [:i| ret at: i put: (keys at: i)].
	^ ret
!
METHOD LDictionary
isEmpty
	^ keys isEmpty
!
METHOD LDictionary
do: aBlock
	values do: aBlock
!
METHOD LDictionary
removeKey: key ifAbsent: exceptionBlock | position |
	position := keys location: key.
	(position <= keys size and: [ key = (keys at: position) ])
		ifTrue: [ keys := keys removeIndex: position.
			values := values removeIndex: position]
		ifFalse: [ ^ exceptionBlock value ]
!
METHOD LDictionary
removeKey: key
	^ self removeKey: key ifAbsent: [ self noKey ]
!
METHOD LDictionary
printString | count res |
	res := self class printString + ' ('.
	count := 0.
	self binaryDo: [:k :elem| 
		(count = 0) ifFalse: [ res := res + ', ' ].
		res := res + (k printString + ' -> ' + elem printString).
		count := count + 1.
		(count >= 20) ifTrue: [ ^ res + ', ...)' ]
	].
	^ res + ')'
!
METHOD LDictionary
add: anAssoc
	self at: anAssoc key put: anAssoc value
!
COMMENT ---------- LSet ------------
METHOD MetaLSet
new: size | ret |
	ret := super new.
	self in: ret at: 1 put: (LArray new: size).
	self in: ret at: 2 put: size.
	^ ret
!
METHOD MetaLSet
with: objA | ret |
	ret := self new.
	ret add: objA.
	^ ret
!
METHOD MetaLSet
with: objA with: objB | ret |
	ret := self new.
	ret add: objA. ret add: objB.
	^ ret
!
METHOD MetaLSet
with: objA with: objB with: objC | ret |
	ret := self new.
	ret add: objA. ret add: objB. ret add: objC.
	^ ret
!
METHOD MetaLSet
new
	^ self new: 10
!
METHOD LSet
size | tally |
	tally := 0.
	members do: [:elem| elem notNil ifTrue: [ tally := tally + 1 ] ].
	^ tally
!
METHOD LSet
grow | bigger old oldsize |
	" Re-create ourselves in place with a new, bigger storage "
	old := members.
	members := LArray new: (old size + growth).

	" Re-insert each existing LSet member "
	old do: [:elem| self add: elem]
!
METHOD LSet
compare: t and: e
	^ t = e
!
METHOD LIdentitySet
compare: t and: e
	^ t == e
!
METHOD LSet
location: elem | pos start t |
	start := pos := (elem hash rem: members size) + 1.
	[ true ] whileTrue: [
		" Return this position if we match, or have reached
		  a nil slot. "
		t := members at: pos.
		((t isNil) or: [self compare: t and: elem]) ifTrue: [
			^ pos
		].

		" Advance to next slot, circularly "
		pos := pos + 1.
		(pos > members size) ifTrue: [
			pos := 1
		].

		" Return nil if we have scanned the whole LSet "
		(pos = start) ifTrue: [ ^ nil ]
	]
!
METHOD LSet
add: elem
     | pos |
	" Find the appropriate slot... if none, need to grow the LSet "
	pos := self location: elem.
	pos isNil ifTrue: [
		self grow.
		^ self add: elem
	].

	" If the slot is nil, this is a new entry which we put in place now.
	  If it wasn't nil, we still re-store it so that if it's an
	  Association, the value portion will be updated. "
	members at: pos put: elem.
	^ elem
!
METHOD LSet
rehash: start
	| pos elem |
	pos := start.
	[ true ] whileTrue: [
		" Advance to next slot, ceasing when we reach our start "
		pos := pos + 1.
		(pos > members size) ifTrue: [ pos := 1 ].
		(pos = start) ifTrue: [ ^ self ].

		" If we reach a nil slot, there are no further rehash
		  worries. "
		elem := members at: pos.
		elem isNil ifTrue: [ ^ self ].

		" Nil out the slot, and then re-insert the element "
		members at: pos put: nil.
		self add: elem
	]
!
METHOD LSet
remove: elem ifAbsent: aBlock | pos |
	" If not found, return error "
	pos := self location: elem.
	((pos isNil) or: [(members at: pos) isNil]) ifTrue: [
		aBlock value
	].

	" Remove our element from the LSet "
	members at: pos put: nil.

	" Re-hash all that follow "
	self rehash: pos.

	^ elem
!
METHOD LSet
remove: elem
	^ self remove: elem ifAbsent: [self noElement ]
!
METHOD LSet
do: aBlock
	members do: [:elem| elem notNil ifTrue: [ aBlock value: elem ]]
!
METHOD LSet
at: value ifAbsent: aBlock | pos |
	pos := self location: value.
	((pos isNil) or: [ (members at: pos) isNil ]) ifTrue: [
		^ aBlock value
	].
	^ value
!
METHOD LSet
indexOf: value
	^ self at: value ifAbsent: [ nil ]
!
COMMENT ---------- LNumber ------------
METHOD MetaLNumber
new
	" can't create this way, return zero "
	^ 0
!
METHOD LNumber
negative
	^self < 0
!
METHOD LNumber
absolute
	(self negative) ifTrue: [ ^ self negated ]
!
METHOD LNumber
negated
	^0-self
!
METHOD LNumber
factorial
	self <= 1 ifTrue: [ ^ 1 ]
	ifFalse: [ ^ (self - 1) factorial * self ]
!
METHOD LNumber
asDigit
	(self < 10) ifTrue:
		[ ^(LChar new: (self asSmallInt + 48)) asString ].
	^(LChar new: (self asSmallInt + 55)) asString
!
METHOD LNumber
printWidth: width base: base | res n dig wasNeg wide |
	res := ''.
	(self negative) ifTrue: [
		wasNeg := true.
		wide := width-1.
		n := self negated
	] ifFalse: [
		wasNeg := false.
		wide := width.
		n := self
	].
	[true] whileTrue: [
		res := ((n rem: base) asDigit) + res.
		n := n quo: base.
		(n = 0) ifTrue: [
			((res size)+1) to: wide do: [:ignore|
				res := '0' + res
			].
			wasNeg ifTrue: [ res := '-' + res ].
			^res
		]
	]
!
METHOD LNumber
printWidth: width
	^self printWidth: width base: 10
!
METHOD LNumber
printString
	^self printWidth: 1 base: 10
!
METHOD LNumber
to: limit
	^ LInterval from: self to: limit step: 1
!
METHOD LNumber
to: limit by: step
	^ LInterval from: self to: limit step: step
!
METHOD LNumber
to: limit do: aBlock  | i |
		" optimize arithmetic loops "
	i := self.
	[ i <= limit ] whileTrue: [ aBlock value: i. i := i + 1 ]
!
METHOD LNumber
to: limit by: step do: aBlock  | i |
	i := self.
	[ i <= limit ] whileTrue: [ aBlock value: i. i := i + step ]
!
METHOD LNumber
overflow
	self error: 'Numeric overflow'
!
METHOD LNumber
bitAnd: arg
	^ (self asSmallInt bitAnd: arg)
!
METHOD LNumber
bitOr: arg
	^ (self asSmallInt bitOr: arg)
!
METHOD LNumber
bitShift: arg
	^ (self asSmallInt bitShift: arg)
!
METHOD LNumber
atRandom
	" Return random number from 1 to self "
	(self < 2) ifTrue: [ ^ self ].
	^ ((1 to: self) atRandom)
!
METHOD LNumber
asChar
	^ LChar new: (self asSmallInt)
!
COMMENT ---------- LSmallInt ------------
METHOD MetaLSmallInt
atRandom
	" Set up seed one time.  TBD: init from something external;
	  getpid() or time() "
	seed isNil ifTrue: [ seed := 17 ].

	" Rotate the random number generator. "
	seed := ((seed * -1043968403 + 12345) truncSmallInt)
		bitAnd: 268435455.
	^ seed
!
METHOD LSmallInt
asSmallInt
	^self
!
METHOD LSmallInt
truncSmallInt
	^self
!
METHOD LSmallInt
asInteger
	^LInteger new: self
!
METHOD LSmallInt
quo: arg
	self primNo: 11 a: self b: arg.
	(arg isMemberOf: LSmallInt) ifFalse: [^self quo: arg asSmallInt].
	(0 = arg) ifTrue: [^ self error: 'division by zero'].
	self primitiveFailed
!
METHOD LSmallInt
rem: arg
	self primNo: 12 a: self b: arg.
	(arg isMemberOf: LSmallInt) ifFalse: [^self rem: arg asSmallInt].
	(0 = arg) ifTrue: [^ self error: 'division by zero'].
	self primitiveFailed
!
METHOD LSmallInt
+ arg
	self primNo: 10 a: self b: arg.
	(arg isMemberOf: LSmallInt) ifFalse: [^self + arg asSmallInt].
	self primitiveFailed
!
METHOD LSmallInt
/ arg
	^self quo: arg
!
METHOD LSmallInt
* arg
	self primNo: 15 a: self b: arg.
	(arg isMemberOf: LSmallInt) ifFalse: [^self * arg asSmallInt].
	self primitiveFailed
!
METHOD LSmallInt
- arg
	self primNo: 16 a: self b: arg.
	(arg isMemberOf: LSmallInt) ifFalse: [^self - arg asSmallInt].
	self primitiveFailed
!
METHOD LSmallInt
< arg
	self primNo: 13 a: self b: arg.
	(arg isMemberOf: LSmallInt) ifFalse: [^self < arg asSmallInt].
	self primitiveFailed
!
METHOD LSmallInt
= arg
	self primNo: 14 a: self b: arg.
	(arg isMemberOf: LSmallInt) ifFalse: [^self = arg asSmallInt].
	self primitiveFailed
!
METHOD LSmallInt
hash
	^ self
!
METHOD LSmallInt
bitOr: arg
	self primNo: 36 a: self b: arg.
	^ (self bitOr: arg asSmallInt)
!
METHOD LSmallInt
bitAnd: arg
	self primNo: 37 a: self b: arg.
	^ (self bitAnd: arg asSmallInt)
!
METHOD LSmallInt
bitShift: arg
	self primNo: 39 a: self b: arg.
	(arg isKindOf: LSmallInt) ifTrue: [ self overflow ].
	^ (self bitShift: arg asSmallInt)
!
COMMENT ---------- LInteger ------------
METHOD MetaLInteger
new: low
	self primNo: 32 a: low.
	self primitiveFailed
!
METHOD LInteger
asInteger
	^self
!
METHOD LInteger
asSmallInt
	self primNo: 33 a: self.
	self overflow
!
METHOD LInteger
truncSmallInt
	self primNo: 40 a: self.
	self primitiveFailed
!
METHOD LInteger
hash
	self primNo: 33 a: self.
	^ (self rem: 65536) asSmallInt
!
METHOD LInteger
quo: arg
	self primNo: 25 a: self b: arg.
	(arg isMemberOf: LInteger) ifFalse: [^self quo: arg asInteger].
	(0 = arg) ifTrue: [^ self error: 'division by zero'].
	self primitiveFailed
!
METHOD LInteger
rem: arg
	self primNo: 26 a: self b: arg.
	(arg isMemberOf: LInteger) ifFalse: [^self rem: arg asInteger].
	(0 = arg) ifTrue: [^ self error: 'division by zero'].
	self primitiveFailed
!
METHOD LInteger
+ arg
	self primNo: 27 a: self b: arg.
	(arg isMemberOf: LInteger) ifFalse: [^self + arg asInteger].
	self primitiveFailed
!
METHOD LInteger
* arg
	self primNo: 28 a: self b: arg.
	(arg isMemberOf: LInteger) ifFalse: [^self * arg asInteger].
	self primitiveFailed
!
METHOD LInteger
- arg
	self primNo: 29 a: self b: arg.
	(arg isMemberOf: LInteger) ifFalse: [^self - arg asInteger].
	self primitiveFailed
!
METHOD LInteger
< arg
	self primNo: 30 a: self b: arg.
	(arg isMemberOf: LInteger) ifFalse: [^self < arg asInteger].
	self primitiveFailed
!
METHOD LInteger
= arg
	self primNo: 31 a: self b: arg.
	(arg isMemberOf: LInteger) ifFalse: [^self = arg asInteger].
	self primitiveFailed
!
COMMENT ---------- LNodes ------------
METHOD MetaLNode
new: value
	" creation, left left and right empty "
	^ self in: self new at: 1 put: value
!
METHOD LNode
do: aBlock
	left notNil ifTrue: [ left do: aBlock ].
	aBlock value: value.
	^ right notNil ifTrue: [ right do: aBlock ]
!
METHOD LNode
reverseDo: aBlock
	right notNil ifTrue: [ right do: aBlock ].
	aBlock value: value.
	left notNil ifTrue: [ left do: aBlock ]
!
METHOD LNode
first
	left notNil
		ifTrue: [ ^ left first ]
		ifFalse: [ ^ value ]
!
METHOD LNode
removeFirst
	left notNil
		ifTrue: [ left := left removeFirst. ^ self ]
		ifFalse: [ ^ right ]
!
METHOD LNode
add: anElement
	value < anElement
		ifTrue: [ right notNil
			ifTrue: [ right add: anElement ]
			ifFalse: [ right := LNode new: anElement ] ]
		ifFalse: [ left notNil
			ifTrue: [ left add: anElement ]
			ifFalse: [ left := LNode new: anElement ] ]
!
METHOD LNode
remove: key ifAbsent: exceptionBlock
	value = key
		ifTrue: [ right notNil
			ifTrue: [ value := right first.
			right := right removeFirst.
			^ self ]
			ifFalse: [ ^ left ] ].
	value < key
		ifTrue: [ right notNil
			ifTrue: [ right := right remove: key ifAbsent: exceptionBlock ]
			ifFalse: [ ^ exceptionBlock value ] ]
		ifFalse: [ left notNil
			ifTrue: [ left := left removeL key ifAbsent: exceptionBlock ]
			ifFalse: [ ^ exceptionBlock value ] ]
!
METHOD LNode
value
	^ value
!
METHOD LNode
at: key ifAbsent: exceptionBlock
	value = key ifTrue: [ ^ value ].
	value < key
		ifTrue: [ right notNil
			ifTrue: [ ^ right at: key ifAbsent: exceptionBlock ]
			ifFalse: [ ^ exceptionBlock value ] ]
		ifFalse: [ left notNil
			ifTrue: [ ^ left at: key ifAbsent: exceptionBlock ]
			ifFalse: [ ^ exceptionBlock value ] ]
!
COMMENT ---------- LIntervals ------------
METHOD MetaLInterval
from: l to: h step: s | newInterval |
	newInterval := self in: self new at: 1 put: l.
	self in: newInterval at: 2 put: h.
	self in: newInterval at: 3 put: s.
	^ newInterval
!
METHOD LInterval
do: aBlock	| current |
	current := low.
	(step < 0)
		ifTrue: [
			[ current >= high ] whileTrue:
				[ aBlock value: current.
				current := current + step ] ]
		ifFalse: [
			[ current <= high ] whileTrue:
				[ aBlock value: current.
				current := current + step ] ]
!
METHOD LInterval
low: l
	low := l
!
METHOD LInterval
high: h
	high := h
!
METHOD LInterval
low
	^ low
!
METHOD LInterval
high
	^ high
!
METHOD LInterval
includes: val
	" Check within range first "
	((val < low) or: [val > high]) ifTrue: [ ^ false ].
	" Then check if in equivalence class of interval "
	^ ((val - low) rem: step) = 0
!
METHOD LInterval
printString | s |
	s := (self class printString) + ' <' +
		low printString + '..' + high printString.
	(step ~= 1) ifTrue: [ s := s + ' by ' + step printString ].
	^ s + '>'
!
METHOD LInterval
atRandom | ret |
	" Return a random element from our sequence "
	ret := (LSmallInt atRandom) rem: ((high - low + 1) quo: step).
	^ low + (ret * step)
!
COMMENT ---------- LLinks ------------
METHOD MetaLLink
value: v
		" return a new link with given value field "
		" and empty link field "
	^ self in: self new at: 1 put: v
!
METHOD MetaLLink
value: v next: n	| new |
		" return a new link with the given fields "
	new := self new.
	self in: new at: 1 put: v.
	self in: new at: 2 put: n.
	^ new
!
METHOD LLink
value
	^ value
!
METHOD LLink
value: val
	value := val
!
METHOD LLink
next
	^ next
!
METHOD LLink
do: aBlock
	aBlock value: value.
	next notNil ifTrue: [ ^ next do: aBlock ]
!
METHOD LLink
remove: anElement ifAbsent: exceptionBlock
	value = anElement
		ifTrue: [ ^ next ]
		ifFalse: [ next notNil
			ifTrue: [ next := next remove: anElement
				ifAbsent: exceptionBlock. ^ self ]
			ifFalse: [ ^ exceptionBlock value ] ]
!
METHOD LLink
reverseDo: aBlock
	next notNil ifTrue: [ next reverseDo: aBlock ].
	aBlock value: value
!
METHOD LLink
addLast: anElement
	next notNil
		ifTrue: [ ^ next addLast: anElement ]
		ifFalse: [ next := LLink value: anElement ]
!
COMMENT ---------- LAssociation ------------
METHOD MetaLAssociation
key: k
		"key is set once, value is resettable"
	^ self in: self new at: 1 put: k
!
METHOD MetaLAssociation
key: k value: v | ret |
		"key is set once, value is resettable"
	ret := self new.
	self in: ret at: 1 put: k.
	self in: ret at: 2 put: v.
	^ ret
!
METHOD LAssociation
= k
		"compare both with keys and associations"
	(k class == LAssociation)
		ifTrue: [ ^ key = k key ]
		ifFalse: [ ^ key = k ]
!
METHOD LAssociation
< k
		"compare both with keys and associations"
	(k class == LAssociation)
		ifTrue: [ ^ key < k key ]
		ifFalse: [ ^ key < k ]
!
METHOD LAssociation
value: v
	value := v
!
METHOD LAssociation
value
	^ value
!
METHOD LAssociation
key
	^ key
!
METHOD LAssociation
hash
	^ key hash
!
METHOD LAssociation
printString
	^ '(' + key printString + ' -> ' + value printString + ')'
!
COMMENT ---------- LTree ------------
METHOD LTree
add: anElement
	root isNil
		ifTrue: [ root := LNode new: anElement ]
		ifFalse: [ root add: anElement ].
	^anElement
!
METHOD LTree
addAll: aCollection
	aCollection do: [:element| self add: element ]
!
METHOD LTree
at: key ifAbsent: exceptionBlock
	root isNil
		ifTrue: [ ^ exceptionBlock value ]
		ifFalse: [ ^ root at: key ifAbsent: exceptionBlock ]
!
METHOD LTree
copy
	^LTree new addAll: self
!
METHOD LTree
collect: transformBlock | newTree |
	newTree := LTree new.
	self do: [:element| newTree add: (transformBlock value: element)].
	^newTree
!
METHOD LTree
do: aBlock
	root notNil ifTrue: [ root do: aBlock ]
!
METHOD LTree
select: testBlock | newTree |
	newTree := LTree new.
	self do: [:element|
		(testBlock value: element)
			ifTrue: [newTree add: element]
	].
	^newTree
!
METHOD LTree
reverseDo: aBlock
	root notNil ifTrue: [ root reverseDo: aBlock ]
!
METHOD LTree
removeFirst
	root isNIl ifTrue: [ self emptyCollection ].
	root := root removeFirst
!
METHOD LTree
remove: key ifAbsent: exceptionBlock
	root isNil
		ifTrue: [ exceptionBlock value ]
		ifFalse: [ root := root remove: key ifAbsent: exceptionBlock ]
!
METHOD LTree
first
	root notNil
		ifTrue: [ ^root first ]
		ifFalse: [ self emptyCollection ]
!
METHOD LTree
isEmpty
	^ root isNil
!
COMMENT --------------file methods-----------------
METHOD MetaLFile
doOpen: nm mode: mode
	self primNo: 100 a: nm b: mode.
!
METHOD MetaLFile
openRead: nm
		" open new file for reading "
	^ self in: (self new) at: 1 put: (self doOpen: nm mode: 'r')
!
METHOD MetaLFile
openWrite: nm
		" open new file for writing "
	^ self in: (self new) at: 1 put: (self doOpen: nm mode: 'w')
!
METHOD MetaLFile
openUpdate: nm
		" open new file for reading and writing "
	^ self in: (self new) at: 1 put: (self doOpen: nm mode: 'r+')
!
METHOD MetaLFile
fileIn: nm | file |
	file := self openRead: nm.
	file opened ifFalse: [ ^ self error: 'cannot open file ' + nm ].
	file fileIn.
	file close.
	^ 'file in completed'
!
METHOD MetaLFile
image: nm | file |
		" open a file, write the image, then close "
	file := self openWrite: nm.
	file opened ifFalse: [ ^ self error: 'cannot open file ' + nm ].
	file writeImage.
	file close
!
METHOD LFile
opened
	^ fileID notNil
!
METHOD LFile
close: id
	self primNo: 103 a: id.
!
METHOD LFile
close
		" close file, return file descriptor "
	fileID notNil ifTrue: [
		self close: fileID.
		fileID := nil
	]
!
METHOD LFile
writeImage
		" save the current image in a file "
	fileID notNil
		ifTrue: [ self primNo: 104 a: fileID ]
!
METHOD LFile
notOpened
	self error: 'file is not open'
!
METHOD LFile
writeCharValue: n
	self primNo: 102 a: fileID b: n.
	fileID isNil ifTrue: [ self notOpened ].
	self primitiveFailed
!
METHOD LFile
doRead
	self primNo: 101 a: fileID.
	fileID isNil ifTrue: [ self notOpened ].
	self primitiveFailed
!
METHOD LFile
readChar	| c |
		" read a single character from a file "
	c := self doRead.
	c notNil ifTrue: [ ^ LChar new: c ].
	^ c
!
METHOD LFile
readLine	| value  c nl |
	" read a line from input "
	fileID isNil ifTrue: [ self error: 'cannot read from unopened file' ].
	value := ''.
	nl := LChar newline.
	[ c := self doRead.
	  c isNil ifTrue: [ ^ nil ].
	  c := LChar new: c.
	  c ~= nl ] whileTrue:
		[ value := value + c asString ].
	^ value
!
METHOD LFile
fileInDispatch: cmd | c |
	" Immediate execte "
	cmd = $+ ifTrue: [
		self readLine doIt printNl.
		^ self
	].

	" Method definition "
	(cmd = $! or: [ cmd = $=]) ifTrue: [
		self methodCommand: cmd = $!.
		^ self
	].

	" Comment enclosed in quotes... find matching quote "
	(cmd = $") ifTrue: [
		[ c := self readChar. c ~= $" ] whileTrue: [
			" Consume chars until closing quote "
			nil
		].
		^ self
	].

	" Blank line, just return to process next line "
	(cmd = LChar newline) ifTrue: [
		^ self
	].

	" It is random chars (treat as comment--discard) "
	self readLine
!
METHOD LFile
fileIn		| cmd |
	[ cmd := self readChar. cmd notNil ] whileTrue: [
		self fileInDispatch: cmd
	]
!
METHOD LFile
methodCommand: classCmd | name aClass text line |
	name := self readLine asSymbol.
	aClass := LSmalltalk at: name ifAbsent: [ ^ self error:
		'unknown class name in file-in: ' + name printString ].
	text := ''.
	[ line := self readLine.
	  line isNil ifTrue: [ ^ self error:
		'unexpected end of input during fileIn' ].
	  line ~= '!'] whileTrue: [ text := text + line + LString newline ].
	classCmd
		ifTrue: [ aClass addMethod: text ]
		ifFalse: [ aClass class addMethod: text ]
!
METHOD LFile
at: idx
	self primNo: 108 a: fileID b: idx.
	self primitiveFailed
!
METHOD LFile
write: buf size: count
	self primNo: 107 a: fileID b: buf c: count.
	self primitiveFailed
!
METHOD LFile
write: buf
	^ self write: buf size: (buf size)
!
METHOD LFile
at: idx put: buf
	self at: idx.
	self write: buf size: buf size
!
METHOD LFile
at: idx get: buf | size |
	self at: idx.
	size := buf size.
	self primNo: 106 a: fileID b: buf c: size.
!
METHOD LFile
at: idx size: count | buf res |
	buf := LByteArray new: count.
	res := self at: idx get: buf.
	(res < count) ifTrue: [ buf := buf from: 1 to: res ].
	^ buf
!
METHOD LFile
newline
	^ self write: (LString newline)
!
COMMENT --------------parser methods-----------------
METHOD LParser
text: aString instanceVars: anArray
	text := aString.
	index := 1.
	lineNum := 1.
	argNames := LArray new: 1.
	argNames at: 1 put: #self.
	instNames := anArray.
	tempNames := LArray new: 0.
	maxTemps := 0
!
METHOD LParser
parse: c with: encoderClass	| encoder meth name |
	" note -- must call text:instanceVars: first "
	errBlock := [ ^ nil ].
	self nextLex.
	encoder := encoderClass new.
	name := self readMethodName.
	(c ~= LUndefined) ifTrue: [
		'Compiling ' print. c print. ':' print.
		name print. '... ' print
	].
	encoder name: name.
	self readMethodVariables.
	self readBody compile: encoder block: false.
	meth := encoder method: maxTemps class: c text: text.
	meth args: argNames inst: instNames temp: tempNames.
	^ meth
!
METHOD LParser
parse: c
	^ self parse: c with: LEncoder
!
METHOD LParser
error: aString
	'Compile error near line ' print.
	lineNum printString print.
	': ' print.
	aString printNl.
	errBlock value
!
METHOD LParser
currentChar
	^ text at: index ifAbsent: [ LChar eof ]
!
METHOD LParser
nextChar
	(self currentChar = LChar newline) ifTrue: [
		lineNum := lineNum + 1
	].
	index := index + 1.
	^ self currentChar
!
METHOD LParser
nextLex	
	self skipBlanks.
	tokenType := self currentChar.
	tokenType isEOF   " end of input "
		ifTrue: [ tokenType := $  . token := nil. ^ nil ].
	tokenType isDigit ifTrue: [ ^ self lexInteger ].
	tokenType isAlphabetic ifTrue: [ ^ self lexAlnum ].
	^ self lexBinary
!
METHOD LParser
skipBlanks  | cc |
	cc := self currentChar.
	[ cc isBlank ] whileTrue: [ cc := self nextChar ].
	( cc = $" ) ifTrue: [ self skipComment ]
!
METHOD LParser
skipComment  | cc |
	[ cc := self nextChar.
	  cc isEOF ifTrue: [ ^ self error: 'unterminated comment'].
	  cc ~= $" ] whileTrue: [ nil ].
	self nextChar. self skipBlanks
!
METHOD LParser
lexInteger	| start |
	start := index.
	[ self nextChar isDigit ]
		whileTrue: [ nil ].
	token := text from: start to: index - 1
!
METHOD LParser
lexAlnum | cc start |
	start := index.
	[ ((cc := self nextChar) isAlphanumeric) or: [ cc = $: ] ]
			whileTrue: [ nil ].
		" add any trailing colons "
	token := text from: start to: index - 1
!
METHOD LParser
lexBinary	| c d |
	c := self currentChar.
	token := c asString.
	d := self nextChar.
	(self charIsSyntax: c) ifTrue: [ ^ token ].
	(((d isBlank
		or: [ d isDigit])
		or: [ d isAlphabetic ])
		or: [ self charIsSyntax: d])
			ifTrue: [ ^ token ].
	token := token + d asString.
	self nextChar
!
METHOD LParser
charIsSyntax: c
	^ ('.()[]#^$;' includes: c) or: [ c = $' ]
!
METHOD LParser
readMethodName   | name |
	self tokenIsName	" unary method "
		ifTrue: [ name := token. self nextLex. ^ name ].
	self tokenIsBinary	" binary method "
		ifTrue: [ name := token. self nextLex.
			self tokenIsName
				ifFalse: [ self error: 'missing argument'].
				self addArgName: token asSymbol.
				self nextLex. ^ name ].
	self tokenIsKeyword
		ifFalse: [ self error: 'invalid method header'].
	name := ''.
	[ self tokenIsKeyword ]
		whileTrue: [ name := name + token. self nextLex.
			self tokenIsName
				ifFalse: [ self error: 'missing argument'].
				self addArgName: token asSymbol.
				self nextLex ].
	^ name
!
METHOD LParser
addArgName: name
	((instNames includes: name)
		or: [ argNames includes: name ])
		ifTrue: [ self error: 'doubly defined argument name: ' +
			name asString].
	argNames := argNames with: name
!
METHOD LParser
tokenIsName
	tokenType isAlphabetic ifFalse: [ ^ false ].
	^ (token at: token size) isAlphanumeric
!
METHOD LParser
tokenIsKeyword
	tokenType isAlphabetic ifFalse: [ ^ false ].
	^ (token at: token size) = $:
!
METHOD LParser
tokenIsBinary
	(((token isNil
		or: [ self tokenIsName])
		or: [ self tokenIsKeyword])
		or: [ self charIsSyntax: tokenType ]) ifTrue: [ ^ false ].
	^ true
!
METHOD LParser
readMethodVariables
	tokenType = $| ifFalse: [ ^ nil ].
	self nextLex.
	[ self tokenIsName ]
		whileTrue: [ self addTempName: token asSymbol. self nextLex ].
	tokenType = $|
		ifTrue: [ self nextLex ]
		ifFalse: [ self error: 'illegal method variable declaration']
!
METHOD LParser
addTempName: name
	(((argNames includes: name)
		or: [ instNames includes: name ] )
		or: [ tempNames includes: name ] )
		ifTrue: [ self error: 'doubly defined name '].
	tempNames := tempNames with: name.
	maxTemps := maxTemps max: tempNames size
!
METHOD LParser
readBody | lnum |
	lnum := lineNum.
	^ (LBodyNode at: lnum) statements: self readStatementList
!
METHOD LParser
readStatementList   | list |
	list := LList new.
	[ list add: self readStatement.
	  tokenType notNil and: [ tokenType = $. ] ]
		whileTrue: [ self nextLex.
			(token isNil or: [ tokenType = $] ] )
				ifTrue: [ ^ list ] ].
	^ list
!
METHOD LParser
readStatement | lnum |
	tokenType = $^
		ifTrue: [ lnum := lineNum. self nextLex.
			^ (LReturnNode at: lnum)
				expression: self readExpression ].
	^ self readExpression
!
METHOD LParser
readExpression   | node lnum |
	self tokenIsName ifFalse: [ ^ self readCascade: self readTerm ].
	node := self nameNode: token asSymbol. self nextLex.
	self tokenIsArrow
		ifTrue: [ node assignable
				ifFalse: [ self error: 'illegal assignment'].
			lnum := lineNum.
			self nextLex.
			^ (LAssignNode at: lnum) target:
				node expression: self readExpression ].
	^ self readCascade: node
!
METHOD LParser
tokenIsArrow
	(token isKindOf: LString) ifFalse: [ ^ false ].
	^ token = ':='
!
METHOD LParser
readTerm   | node lnum |
	token isNil
		ifTrue: [ self error: 'unexpected end of input' ].
	tokenType = $(
		ifTrue: [ self nextLex. node := self readExpression.
			tokenType = $)
				ifFalse: [ self error: 'unbalanced parenthesis' ].
			self nextLex. ^ node ].
	tokenType = $[ ifTrue: [ ^ self readBlock ].
	tokenType = $< ifTrue: [ ^ self readPrimitive ].
	self tokenIsName
		ifTrue: [ node := self nameNode: token asSymbol.
			self nextLex. ^ node ].
	lnum := lineNum.
	^ (LLiteralNode at: lnum) value: self readLiteral
!
METHOD LParser
nameNode: name
	" make a new name node "
	| tmp |
	name == #super
		ifTrue: [ ^ (LArgumentNode at: lineNum) position: 0 ].
	(1 to: tempNames size) do: [:i |
		(name == (tempNames at: i))
			ifTrue: [ ^ (LTemporaryNode at: lineNum)
				position: i ] ].
	(1 to: argNames size) do: [:i |
		(name == (argNames at: i))
			ifTrue: [ ^ (LArgumentNode at: lineNum) position: i ] ].
	(1 to: instNames size) do: [:i |
		(name == (instNames at: i))
			ifTrue: [ ^ (LInstNode at: lineNum) position: i ] ].
	tmp := (LLiteralNode at: lineNum).
	^ tmp
		value: (LSmalltalk at: name
			ifAbsent: [ ^ self error:
				'unrecognized name: ' + name printString ])
!
METHOD LParser
readLiteral   | node |
	tokenType = $$
		ifTrue: [ node := self currentChar.
			self nextChar. self nextLex. ^ node ].
	tokenType isDigit
		ifTrue: [ ^ self readInteger ].
	token = '-'
		ifTrue: [ self nextLex. ^ self readInteger negated ].
	tokenType = $'
		ifTrue: [ ^ self readString ].
	tokenType = $#
		ifTrue: [ ^ self readSymbol ].
	self error: 'invalid literal: ' + token
!
METHOD LParser
readInteger  | value |
	value := token asNumber.
	value isNil ifTrue: [ self error: 'integer expected' ].
	self nextLex.
	^ value
!
METHOD LParser
readString  | first last cc |
	first := index.
	[ cc := self currentChar.
	  cc isNil ifTrue: [ self error: 'unterminated string constant'].
	  cc ~= $' ] whileTrue: [ index := index + 1 ].
	last := index - 1.
	self nextChar = $'
		ifTrue: [ self nextChar.
			^ (text from: first to: index - 2) + self readString ].
	self nextLex.
	^ text from: first to: last
!
METHOD LParser
readSymbol   | cc |
	cc := self currentChar.
	(cc isEOF or: [ cc isBlank])
		ifTrue: [ self error: 'invalid symbol'].
	cc = $( ifTrue: [ ^ self readArray ].
	(self charIsSyntax: cc)
		ifTrue: [ self error: 'invalid symbol'].
	self nextLex.
	cc := LSymbol new: token. self nextLex.
	^ cc
!
METHOD LParser
readArray	| value |
	self nextChar. self nextLex. value := LArray new: 0.
	[ tokenType ~= $) ]
		whileTrue: [ value := value with: self arrayLiteral ].
	self nextLex.
	^ value
!
METHOD LParser
arrayLiteral	| node |
	tokenType isAlphabetic
		ifTrue: [ node := LSymbol new: token. self nextLex. ^ node ].
	^ self readLiteral
!
METHOD LParser
readPrimitive  | num args lnum |
	lnum := lineNum.
	self nextLex.
	num := self readInteger.
	args := LList new.
	[ tokenType ~= $> ]
		whileTrue: [ args add: self readTerm ].
	self nextLex.
	^ (LPrimitiveNode at: lnum) number: num arguments: args
!
METHOD LParser
readBlock    | stmts saveTemps lnum |
	saveTemps := tempNames.
	lnum := lineNum.
	self nextLex.
	tokenType = $:
		ifTrue: [ self readBlockTemporaries ].
	stmts := self readStatementList.
	tempNames := saveTemps.
	tokenType = $]
		ifTrue: [ self nextLex.
			^ (LBlockNode at: lnum) statements: stmts
				temporaryLocation: saveTemps size ]
		ifFalse: [ self error: 'unterminated block']
!
METHOD LParser
readBlockTemporaries
	[ tokenType = $: ]
		whileTrue: [ self currentChar isAlphabetic
			ifFalse: [ self error: 'ill formed block argument'].
			self nextLex.
			self tokenIsName
				ifTrue: [ self addTempName: token asSymbol ]
				ifFalse: [ self error: 'invalid block argument list '].
			self nextLex ].
	tokenType = $|
		ifTrue: [ self nextLex ]
		ifFalse: [ self error: 'invalid block argument list ']
!
METHOD LParser
readCascade: base   | node list |
	node := self keywordContinuation: base.
	tokenType = $;
		ifTrue: [ node := (LCascadeNode at: lineNum) head: node.
			list := LList new.
			[ tokenType = $; ]
				whileTrue: [ self nextLex.
					list add:
						(self keywordContinuation: nil ) ].
			node list: list ].
	^ node
!
METHOD LParser
keywordContinuation: base  | receiver name args lnum |
	receiver := self binaryContinuation: base.
	self tokenIsKeyword
		ifFalse: [ ^ receiver ].
	name := ''.
	args := LList new.
	lnum := lineNum.
	[ self tokenIsKeyword ]
		whileTrue: [ name := name + token. self nextLex.
			args add:
				(self binaryContinuation: self readTerm) ].
	^ (LMessageNode at: lnum) receiver:
		receiver name: name asSymbol arguments: args
!
METHOD LParser
binaryContinuation: base | receiver name lnum |
	receiver := self unaryContinuation: base.
	[ self tokenIsBinary]
		whileTrue: [ lnum := lineNum.
			name := token asSymbol. self nextLex.
			receiver := (LMessageNode at: lnum)
				receiver: receiver name: name arguments:
					(LList with:
						(self unaryContinuation: self readTerm)) ].
	^ receiver
!
METHOD LParser
unaryContinuation: base | receiver lnum |
	receiver := base.
	[ self tokenIsName ]
		whileTrue: [ lnum := lineNum.
			receiver := (LMessageNode at: lnum)
				receiver: receiver name: token asSymbol
					arguments: (LList new).
				self nextLex ].
	^ receiver
!
METHOD MetaLParserNode
new
	self error: 'Must use at: for creation'
!
METHOD MetaLParserNode
at: l | ret |
	ret := super new.
	self in: ret at: 1 put: l.
	^ ret
!
METHOD LParserNode
isSuper
	^ false
!
METHOD LParserNode
isBlock
	^ false
!
METHOD LParserNode
assignable
	^ false
!
METHOD LParserNode
compile: encoder
	encoder lineNum: lineNum
!
METHOD LBodyNode
statements: s
	statements := s
!
METHOD LBodyNode
compile: encoder block: inBlock
	super compile: encoder.
	statements reverseDo:
		[ :stmt | stmt compile: encoder block: inBlock.
			encoder genHigh: 15 low: 5 " pop "].
	encoder genHigh: 15 low: 1 " return self "
!
METHOD LReturnNode
expression: e
	expression := e
!
METHOD LReturnNode
compile: encoder block: inBlock
	super compile: encoder.
	expression compile: encoder block: inBlock.
	inBlock
		ifTrue: [ encoder genHigh: 15 low: 3 " block return " ]
		ifFalse: [ encoder genHigh: 15 low: 2 " stack return " ]
!
METHOD LAssignNode
target: t expression: e
	target := t.
	expression := e
!
METHOD LAssignNode
compile: encoder block: inBlock
	super compile: encoder.
	expression compile: encoder block: inBlock.
	target assign: encoder
!
METHOD LLiteralNode
value: v
	value := v
!
METHOD LLiteralNode
compile: encoder block: inBlock
	super compile: encoder.
	value == nil ifTrue: [ ^ encoder genHigh: 5 low: 10 ].
	value == true ifTrue: [ ^ encoder genHigh: 5 low: 11 ].
	value == false ifTrue: [ ^ encoder genHigh: 5 low: 12 ].
	(((value class == LSmallInt) and:
	 [value < 10]) and: [value negative not])
		ifTrue: [ ^ encoder genHigh: 5 low: value ].
	encoder genHigh: 4 low: (encoder genLiteral: value)
!
METHOD LArgumentNode
position: p
	position := p
!
METHOD LArgumentNode
isSuper
	^ position = 0
!
METHOD LArgumentNode
compile: encoder block: inBlock
	super compile: encoder.
	position = 0
		ifTrue: [ encoder genHigh: 2 low: 0 ]
		ifFalse: [ encoder genHigh: 2 low: position - 1 ]
!
METHOD LTemporaryNode
position: p
	position := p
!
METHOD LTemporaryNode
compile: encoder block: inBlock
	super compile: encoder.
	encoder genHigh: 3 low: position - 1
!
METHOD LTemporaryNode
assignable
	^ true
!
METHOD LTemporaryNode
assign: encoder
	encoder genHigh: 7 low: position - 1
!
METHOD LInstNode
position: p
	position := p
!
METHOD LInstNode
compile: encoder block: inBlock
	super compile: encoder.
	encoder genHigh: 1 low: position - 1
!
METHOD LInstNode
assign: encoder
	encoder genHigh: 6 low: position - 1
!
METHOD LInstNode
assignable
	^ true
!
METHOD LPrimitiveNode
number: n arguments: a
	number := n.
	arguments := a.
!
METHOD LPrimitiveNode
compile: encoder block: inBlock | argsize |
	argsize := arguments size.
	super compile: encoder.
	encoder pushArgs: argsize.
	arguments reverseDo: [ :a | a compile: encoder block: inBlock ].
	encoder genHigh: 13 low: argsize.
	encoder genCode: number.
	encoder popArgs: argsize
!
METHOD LBlockNode
statements: s temporaryLocation: t
	statements := s.
	temporaryLocation := t
!
METHOD LBlockNode
compileInLine: encoder block: inBlock
	statements reverseDo:
		[ :stmt | stmt compile: encoder block: inBlock.
			encoder genHigh: 15 low: 5 " pop top " ].
	encoder backUp
!
METHOD LBlockNode
isBlock
	^ true
!
METHOD LBlockNode
compile: encoder block: inBlock | patchLocation |
	super compile: encoder.
	encoder genHigh: 12 low: temporaryLocation.
	patchLocation := encoder genVal: 0.
	self compileInLine: encoder block: true.
	encoder genHigh: 15 low: 2. " return top of stack "
	encoder patch: patchLocation
!
METHOD LCascadeNode
head: h
	head := h
!
METHOD LCascadeNode
list: l
	list := l
!
METHOD LCascadeNode
compile: encoder block: inBlock
	super compile: encoder.
	head compile: encoder block: inBlock.
	list reverseDo: [ :stmt |
		encoder genHigh: 15 low: 4. " duplicate "
		stmt compile: encoder block: inBlock.
		encoder genHigh: 15 low: 5 "pop from stack " ]
!
METHOD LMessageNode
receiver: r name: n arguments: a
	receiver := r.
	name := n.
	arguments := a
!
METHOD LMessageNode
compile: encoder block: inBlock
	super compile: encoder.
	receiver isNil
		ifTrue: [ ^ self cascade: encoder block: inBlock ].
	((receiver isBlock and: [ self argumentsAreBlock ])
		and: [name = #whileTrue: or: [ name = #whileFalse ] ] )
		ifTrue: [ ^ self optimizeWhile: encoder block: inBlock ].
	receiver compile: encoder block: inBlock.
	receiver isSuper
		ifTrue: [ ^ self sendToSuper: encoder block: inBlock ].
	name = #isNil ifTrue: [ ^ encoder genHigh: 10 low: 0 ].
	name = #notNil ifTrue: [ ^ encoder genHigh: 10 low: 1 ].
	self compile2: encoder block: inBlock
!
METHOD LMessageNode
compile2: encoder block: inBlock
	self argumentsAreBlock ifTrue: [
		name = #ifTrue: ifTrue: [ ^ self compile: encoder
				test: 8 constant: 10 block: inBlock ].
		name = #ifFalse: ifTrue: [ ^ self compile: encoder
				test: 7 constant: 10 block: inBlock ].
		name = #and: ifTrue: [ ^ self compile: encoder
				test: 8 constant: 12 block: inBlock ].
		name = #or: ifTrue: [ ^ self compile: encoder
				test: 7 constant: 11 block: inBlock ].
		name = #ifTrue:ifFalse:
			ifTrue: [ ^ self optimizeIf: encoder block: inBlock ].
		].
	self evaluateArguments: encoder block: inBlock.
	name = '<' asSymbol ifTrue: [ ^ encoder genHigh: 11 low: 0].
	name = '<=' asSymbol ifTrue: [ ^ encoder genHigh: 11 low: 1].
	name = '+' asSymbol ifTrue: [ ^ encoder genHigh: 11 low: 2].
	self sendMessage: encoder block: inBlock
!
METHOD LMessageNode
sendToSuper: encoder block: inBlock
	self evaluateArguments: encoder block: inBlock.
	encoder genHigh: 8 low: 1 + arguments size.
	encoder genHigh: 15 low: 11.
	encoder genCode: (encoder genLiteral: name)
!
METHOD LMessageNode
cascade: encoder block: inBlock
	self evaluateArguments: encoder block: inBlock.
	self sendMessage: encoder block: inBlock
!
METHOD LMessageNode
evaluateArguments: encoder block: inBlock
	encoder pushArgs: 1 + arguments size.
	arguments reverseDo: [ :arg |
		arg compile: encoder block: inBlock ]
!
METHOD LMessageNode
sendMessage: encoder block: inBlock
	encoder popArgs: arguments size.
		" mark arguments, then send message "
	encoder genHigh: 8 low: 1 + arguments size.
	encoder genHigh: 9 low: (encoder genLiteral: name)
!
METHOD LMessageNode
argumentsAreBlock
	arguments do: [ :arg | arg isBlock ifFalse: [ ^ false ]].
	^ true
!
METHOD LMessageNode
optimizeWhile: encoder block: inBlock | start save |
	start := encoder currentLocation.
	receiver compileInLine: encoder block: inBlock.
	name = #whileTrue:	" branch if false/true "
		ifTrue: [ encoder genHigh: 15 low: 8 ]
		ifFalse: [ encoder genHigh: 15 low: 7 ].
	save := encoder genVal: 0.
	arguments first compileInLine: encoder block: inBlock.
	encoder genHigh: 15 low: 5. " pop from stack "
	encoder genHigh: 15 low: 6. " branch "
	encoder genVal: start. " branch target "
	encoder patch: save.
	encoder genHigh: 5 low: 10  " push nil "
!
METHOD LMessageNode
compile: encoder test: t constant: c block: inBlock | save ssave |
	super compile: encoder.
	encoder genHigh: 15 low: t.  " branch test "
	save := encoder genVal: 0.
	arguments first compileInLine: encoder block: inBlock.
	encoder genHigh: 15 low: 6.  " branch "
	ssave := encoder genVal: 0.
	encoder patch: save.
	encoder genHigh: 5 low: c.  " push constant "
	encoder patch: ssave
!
METHOD LMessageNode
optimizeIf: encoder block: inBlock | save ssave |
	encoder genHigh: 15 low: 7.  " branch if true test "
	save := encoder genVal: 0.
	arguments first compileInLine: encoder block: inBlock.
	arguments removeFirst.
	encoder genHigh: 15 low: 6.  " branch "
	ssave := encoder genVal: 0.
	encoder patch: save.
	arguments first compileInLine: encoder block: inBlock.
	encoder patch: ssave
!
METHOD LEncoder
name: n
	name := n asSymbol.
	byteCodes := LByteArray new: 20.
	index := 0.
	literals := LArray new: 0.
	stackSize := 0.
	maxStack := 1.
!
METHOD LEncoder
lineNum: l
	" Don't care, except in DebugEncoder subclass "
!
METHOD LEncoder
pushArgs: n
	stackSize := stackSize + n.
	maxStack := stackSize max: maxStack
!
METHOD LEncoder
popArgs: n
	stackSize := stackSize - n.
!
METHOD LEncoder
genLiteral: aValue | idx |
	idx := literals indexOf: aValue.
	idx notNil ifTrue: [ ^ idx - 1 ].
	literals := literals with: aValue.
	^ literals size - 1
!
METHOD LEncoder
genHigh: high low: low
	(low >= 16)
		ifTrue: [ self genHigh: 0 low: high. self genCode: low ]
		ifFalse: [ self genCode: high * 16 + low ]
!
METHOD LEncoder
genCode: byte
	index := index + 1.
	(index >= byteCodes size)
		ifTrue: [ self expandByteCodes].
	byteCodes at: index put: byte.
	^ index
!
METHOD LEncoder
genVal: byte
	self genCode: (byte rem: 256).
	self genCode: (byte quo: 256).
	^ index-1
!
METHOD LEncoder
expandByteCodes	| newarray size |
	size := byteCodes size.
	newarray := LByteArray new: size + 8.
	1 to: size do: [:i | newarray at: i put: (byteCodes at: i)].
	byteCodes := newarray
!
METHOD LEncoder
patch: loc
		" patch a goto from a block "
	byteCodes at: loc put: (index rem: 256).
	byteCodes at: (loc + 1) put: (index quo: 256)
!
METHOD LEncoder
currentLocation
	^ index
!
METHOD LEncoder
backUp
	" back up one instruction "
	index := index - 1
!
METHOD LEncoder
method: maxTemps class: c text: text
	^ LMethod name: name byteCodes: byteCodes literals: literals
		stackSize: maxStack temporarySize: maxTemps class: c
		text: text
!
BEGIN nil main
END
